#include "xheaacsuperframe.h"

XHEAACSuperFrame::XHEAACSuperFrame():AudioSuperFrame (),numChannels(0),frameSize(0),previous(),partialFrame()
{
}

void
XHEAACSuperFrame::init(const CAudioParam& audioParam, unsigned frameSize)
{
    numChannels = audioParam.AM_MONO?1:2;
    this->frameSize = frameSize;
}


        /*
     * 5.3.1.3 Transport of xHE-AAC audio frames within the payload section
    The USAC access unit encoder generates a continuous sequence of audio frames at a constant bit rate over the long term.
    The individual length of each audio frame in the continuous sequence is variable but constrained by the bit
    reservoir mechanism in the audio encoder to allow for improved audio quality. The encoder's bit reservoir buffer level is
    signalled to the decoder, to reduce required input buffer size and the extra tune-in delay to a minimum.

    Audio frame transport

    The xHE-AAC audio encoder generates a sequence of audio super frames (occupying one DRM logical frame for robustness modes A, B, C and D,
    or two DRM logical frames for robustness mode E). The audio frames as generated by the USAC access unit encoder are inserted into
    the Payload section of the audio super frame as a continuous byte sequence without any padding bytes in-between.
    Should padding be required to achieve the overall fixed bit rate and byte-alignment, it is inserted by the USAC access unit encoder
    into the audio frames themselves.

    The frame borders of audio frames do not need to be and typically will not be aligned with the audio super frame boundaries.
    Instead, audio frames are not synchronized to audio super frames; they continue from the current audio super frame into the Payload
    section of subsequent audio super frame(s). The frame borders within the Payload section of an audio super frame can be derived from
    the Header and Directory section of the audio super frame (there may be none!).

    An audio super frame shall not contain a Frame border description element without at least one byte of the corresponding audio frame data.
    If the available space in an audio super frame is not sufficient to hold at least 1 byte of the next audio frame in the Payload section
    plus the 2 bytes of the related extra Frame border description element in the Directory section, then the remaining space in the Payload
    section shall be filled with audio frame content, while the related Frame border description element is carried as the first Frame border
    description element in the Directory section of the following audio super frame (i.e. located at the end of the Directory section).
    The Frame border index value of such a delayed Frame border description element shall carry the special value 0xFFE or 0xFFF; with 0xFFF
    indicating the start of the audio frame at the last byte of the Payload section of the previous audio super frame. A decoder therefore
    always needs to buffer the last 2 bytes within the Payload section for a possible later processing along with the next audio super frame.
     */
    /*
    * The xHE-AAC audio super frame Header section has the following structure:
    • Frame border count
    • Bit reservoir level
    • Fixed header CRC
    The following definitions apply:
    4 bits. 4 bits. 8 bits
    * */
bool XHEAACSuperFrame::parse(CVectorEx<_BINARY>& asf)
{
    bool ok = true;
    unsigned frameBorderCount = asf.Separate(4);
    unsigned bitReservoirLevel = asf.Separate(4);
    unsigned iheaderCRC = asf.Separate(8);
    // TODO check CRC
    // TODO handle frames split across audio superframes
    // TODO handle reservoir
    unsigned bitResLevel = (bitReservoirLevel+1) * 384 * numChannels;
    // get the directory
    unsigned directory_offset = 8*(frameSize - 2*frameBorderCount);
    cerr << "bit reservoir level " << bitReservoirLevel << " bitResLevel " << bitResLevel << " frame size " << frameSize << " directory offset " << directory_offset << " bits " << (directory_offset/SIZEOF__BYTE) << " bytes" << endl;
    CVector<_BINARY> vecbiDirectory(int(16 * frameBorderCount));
    for (unsigned i = 0; i < 16 * frameBorderCount; i++) {
        vecbiDirectory[int(i)] = asf[int(directory_offset + i)];
    }
    vecbiDirectory.ResetBitAccess();
    vector<size_t> vecborders;
    vecborders.resize(unsigned(frameBorderCount));
    for(int i=int(frameBorderCount-1); i>=0; i--) {
        int frameBorderIndex = int(vecbiDirectory.Separate(12));
        int frameBorderCountRepeat = int(vecbiDirectory.Separate(4));
        if(frameBorderCountRepeat != frameBorderCount) {
            ok = false;
        }
        cerr << "border " << i << " of " << frameBorderCountRepeat << "/" << frameBorderCount << " starts at " << hex << frameBorderIndex << dec << endl;
        vecborders[unsigned(i)] = size_t(frameBorderIndex);
    }
    switch(vecborders[0]) {
    case 0xffe: // delayed from previous superframe
        cerr << "frame starts in previous superframe" << endl;
        break;
    case 0xfff: // the start of the audio frame at the last byte of the Payload section of the previous audio super frame
        cerr << "frame has one bytr in previous superframe" << endl;
        break;
    default: // boundary in this superframe
        cerr << "frame starts in this superframe" << endl;
        break;
    }
    if(!ok) {
        return false;
    }
    // now separate the frames using the borders
    audioFrame.resize(frameBorderCount);
    unsigned start = vecborders[0];
    audioFrame[0].resize(partialFrame.size()+start-2);
    for (size_t j = 0; j < partialFrame.size(); j++)
    {
        audioFrame[0][j] = partialFrame[j];
    }
    for (size_t j = partialFrame.size(); j < audioFrame[0].size(); j++)
    {
        audioFrame[0][j] = uint8_t(asf.Separate(8));
    }
    for (size_t i = 1; i < audioFrame.size(); i++)
    {
        cerr << hex << "extracting frame " << i << " from offset " << start << " to offset " << vecborders[i] << dec << endl;
        audioFrame[i].resize(vecborders[i]);
        for (size_t j = 0; j < audioFrame[i].size(); j++) {
            audioFrame[i][j] = uint8_t(asf.Separate(8));
        }
        start = vecborders[i];
    }
    partialFrame.resize(directory_offset/SIZEOF__BYTE-start);
    for (size_t j = 0; j < partialFrame.size(); j++) {
        partialFrame[j] = uint8_t(asf.Separate(8));
    }
    return ok;
}

